<h2 class="text-3xl font-bold mb-4">Chapter 5.4: The Ultimate Tool: TracePlus</h2>
<p><strong>The Problem:</strong> In Chapter 4.3, we hit a wall. The standard <code>TraceLine</code> function is fundamentally broken for gameplay scripting because it is blind to all entities. Your security beam couldn't detect a player, and your turret couldn't see a cube.</p>

<h3 class="text-2xl font-bold mt-8 mb-4">The Solution: A Raycast That Actually Sees</h3>
<p>PCapture-Lib's <code>TracePlus.Bbox</code> is a complete replacement for <code>TraceLine</code>. It performs a highly optimized trace that correctly collides with both world geometry and the bounding boxes of all entities.</p>
<p>Furthermore, it returns a convenient result object, so you no longer need to manually calculate the hit position.</p>
<pre><code class="language-squirrel">// The security beam from Chapter 4.3, now fully functional.
function CheckSecurityBeam() {
    local startPos = entLib.FindByName(null, "beam_start").GetOrigin()
    local endPos = entLib.FindByName(null, "beam_end").GetOrigin()
    local player = GetPlayerEx()

    // Fire the trace, ignoring the player for this check.
    local trace = TracePlus.Bbox(startPos, endPos, player)

    // Did the trace hit something? And was that something NOT the world?
    if (trace.DidHit() && trace.GetEntity() != null) {
        printl("BEAM BLOCKED BY ENTITY: " + trace.GetEntity().GetClassname())
        return 0.1
    }
    
    printl("Path is clear.")
    return 0.1
}
</code></pre>

<h3 class="text-2xl font-bold mt-8 mb-4">The Killer Features</h3>
<p><code>TracePlus</code> is more than just a fix; it's a massive upgrade.</p>
<ul class="list-disc list-inside space-y-2">
    <li><strong>Flexible Filtering:</strong> You can provide a `TracePlus.Settings` object to precisely control what the trace can hit. You can ignore entire classes of entities (like `trigger_*`), prioritize others, or even write your own custom filter functions.</li>
    <li><strong>Portal Traversal:</strong> This is the feature that makes PCapture-Lib legendary. <code>TracePlus.PortalBbox</code> can trace a path *through* portals, correctly calculating the new direction and position. This allows for creating portal-based puzzles and mechanics that are simply impossible with the standard engine tools.</li>
</ul>
<pre><code class="language-squirrel">// Conceptual example of a portal trace
local startPos = player.EyePosition()
local endPos = startPos + (player.EyeForwardVector() * 1000)

// This trace will correctly follow the ray through any active portals.
local trace = TracePlus.PortalBbox(startPos, endPos, player)

if (trace.DidHit()) {
    // The GetHitPos() will be the correct position in world space,
    // even if it's on the other side of a portal.
    DrawBeams(trace.GetHitPos())
}
</code></pre>