<h2 class="text-3xl font-bold mb-4">Chapter 5.3: Perfect Timing: ActionScheduler</h2>
<p><strong>The Problem:</strong> As you saw in Chapter 2.4, creating timed sequences with the standard <code>EntFire</code> function is a chore. You have to manually calculate cumulative delays, making the code hard to read and modify.</p>

<h3 class="text-2xl font-bold mt-8 mb-4">The Solution: Simple, Readable Scheduling</h3>
<p>PCapture-Lib's <code>ActionScheduler</code> module replaces this clumsy system with clean, intuitive functions.</p>
<pre><code class="language-squirrel">// A simple delay. This is much cleaner than a delayed EntFire.
function SayMessage() {
    printl("This message appears after 2 seconds.")
}
ScheduleEvent.Add("MyMessage", SayMessage, 2.0)

// An action that repeats every second, forever.
function Tick() {
    printl("TICK!")
}
ScheduleEvent.AddInterval("MyInterval", Tick, 1.0)
</code></pre>

<h3 class="text-2xl font-bold mt-8 mb-4">The Power of <code>yield</code>: Sequential Code with Pauses</h3>
<p>The most powerful feature of the scheduler is the ability to write asynchronous code. The <code>yield</code> keyword lets you pause a function's execution for a set time, then resume exactly where you left off. This allows you to write timed sequences in a natural, linear way.</p>
<pre><code class="language-squirrel">// The light sequence from Chapter 2.4, rewritten with ActionScheduler.
function RunLightSequence() {
    printl("Sequence started...")
    EntFire("light_1", "TurnOn")
    yield 1.0 // Wait for 1 second. Simple.

    EntFire("light_2", "TurnOn")
    yield 1.0 // Wait for another second.

    EntFire("light_3", "TurnOn")
    yield 2.5 // Wait longer.

    EntFire("light_*", "TurnOff")
    printl("Sequence complete.")
}

// Remember: to use 'yield', the function must be started via the scheduler.
ScheduleEvent.Add("LightSequence", RunLightSequence, 0)
</code></pre>

<div class="p-4 bg-red-100 dark:bg-red-900 border-l-4 border-red-500 rounded-r-lg">
    <strong>CRITICAL WARNING: Save/Load and <code>yield</code></strong><br>
    The Source Engine's save/load system does <strong>not</strong> support asynchronous VScript functions. If a player saves the game while a function is "paused" on a <code>yield</code> statement, <strong>loading that save will crash the game.</strong> (Thx Valve)<br><br>
    Therefore, you should only use <code>yield</code> for:
    <ul class="list-disc list-inside ml-4">
        <li>Short, non-critical animations or sequences where a save is unlikely.</li>
        <li>Debugging purposes.</li>
        <li>Essential but extremely short pauses (e.g., waiting one frame, `yield 0.01` ) for interacting with the file system or console commands.</li>
    </ul>
    For important, long-running game logic, it is safer to use a chain of <code>ScheduleEvent.Add()</code> calls.
</div>